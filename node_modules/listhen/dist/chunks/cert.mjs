import { promisify } from 'node:util';
import forge from 'node-forge';
import ipRegex from 'ip-regex';

async function generateSSLCert(opts) {
  const attributes = [
    { name: "commonName", value: opts.commonName || opts.domains[0] }
  ];
  const extensions = [
    { name: "basicConstraints", cA: false, critical: true },
    { name: "keyUsage", digitalSignature: true, keyEncipherment: true, critical: true },
    { name: "extKeyUsage", serverAuth: true, clientAuth: true },
    {
      name: "subjectAltName",
      altNames: opts.domains.map((domain) => {
        const types = { domain: 2, ip: 7 };
        const isIp = ipRegex({ exact: true }).test(domain);
        if (isIp) {
          return { type: types.ip, ip: domain };
        }
        return { type: types.domain, value: domain };
      })
    }
  ];
  const ca = forge.pki.certificateFromPem(opts.caCert);
  return await generateCert({
    subject: attributes,
    issuer: ca.subject.attributes,
    extensions,
    validityDays: opts.validityDays,
    signWith: opts.caKey
  });
}
async function generateCA(opts = {}) {
  const attributes = [
    opts.commonName && { name: "commonName", value: opts.commonName },
    opts.countryCode && { name: "countryName", value: opts.countryCode },
    opts.state && { name: "stateOrProvinceName", value: opts.state },
    opts.locality && { name: "localityName", value: opts.locality },
    opts.organization && { name: "organizationName", value: opts.organization }
  ].filter(Boolean);
  const extensions = [
    { name: "basicConstraints", cA: true, critical: true },
    { name: "keyUsage", keyCertSign: true, critical: true }
  ];
  return await generateCert({
    subject: attributes,
    issuer: attributes,
    extensions,
    validityDays: opts.validityDays || 365
  });
}
async function generateCert(opts) {
  const serial = Math.floor(Math.random() * 95e3 + 5e4).toString();
  const generateKeyPair = promisify(forge.pki.rsa.generateKeyPair.bind(forge.pki.rsa));
  const keyPair = await generateKeyPair({ bits: 2048, workers: 4 });
  const cert = forge.pki.createCertificate();
  cert.publicKey = keyPair.publicKey;
  cert.serialNumber = Buffer.from(serial).toString("hex");
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setDate(cert.validity.notAfter.getDate() + opts.validityDays);
  cert.setSubject(opts.subject);
  cert.setIssuer(opts.issuer);
  cert.setExtensions(opts.extensions);
  const signWith = opts.signWith ? forge.pki.privateKeyFromPem(opts.signWith) : keyPair.privateKey;
  cert.sign(signWith, forge.md.sha256.create());
  return {
    key: forge.pki.privateKeyToPem(keyPair.privateKey),
    cert: forge.pki.certificateToPem(cert)
  };
}

export { generateCA, generateCert, generateSSLCert };
